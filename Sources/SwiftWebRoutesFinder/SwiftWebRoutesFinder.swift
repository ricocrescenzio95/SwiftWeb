import Foundation
import Foundation
import SwiftSyntax
import SwiftParser

extension SwiftWebRoutesFinder {
  static func main() throws {
    try SwiftWebRoutesFinder(
      inputFolder: URL(string: CommandLine.arguments[1])!,
      outputFile: URL(string: CommandLine.arguments[2])!
    ).build()
  }
}

@main
class SwiftWebRoutesFinder {
  let inputFolder: URL
  let outputFile: URL
  
  struct RouteInfo {
    let route: (name: String, params: [(name: String, type: String)])
    let typeName: String
    let hasParameters: Bool
  }
  
  var routeInfos: [RouteInfo] = []
  
  init(inputFolder: URL, outputFile: URL) {
    self.inputFolder = inputFolder
    self.outputFile = outputFile
  }
  
  func build() throws {
    populateSegments()
    
    // Generate switch cases
    var allCases: [String] = []
    var factoryMethods: [String] = []
    
    for info in routeInfos {
      let camelCaseTypeName = info.typeName.prefix(1).lowercased() + info.typeName.dropFirst()
      if info.hasParameters {
        // Generate regex pattern matching case with where clause
        let regexPattern = convertRouteToRegex(info.route.name)
        allCases.append("case let route where route.range(of: \"^\(regexPattern)$\", options: .regularExpression) != nil: \(info.typeName)(context)")
        factoryMethods.append(
          """
          static func \(camelCaseTypeName)(\(info.route.params.map { "\($0.name): \($0.type)" }.joined(separator: ", "))) -> PageDestination<\(info.typeName)> {
            \(info.typeName).makeDestination(\(info.route.params.map { "\($0.name): \($0.name)" }.joined(separator: ", ")))
          }
          """
        )
      } else {
        // Simple case for static routes
        allCases.append("case \"\(info.route)\": \(info.typeName)()")
        factoryMethods.append(
          """
          static func \(camelCaseTypeName)() -> PageDestination<\(info.typeName)> {
          \(info.typeName).makeDestination()
          }
          """
        )
      }
    }
    
    let code = """
    import SwiftWeb
    import Foundation
    
    // AUTO-GENERATED BY SwiftWebRoutesFinder
    
    extension App {
      @HTMLBuilder
      public static func __page(for route: String, context: Router.Context) -> some Node {
        let _ = print("route", route)
        
        switch route {
        case "/": Self()
        \(allCases.joined(separator: "\n    "))
        default: Self.notFound
        }
      }
    }
    
    extension PageDestination {
      \(factoryMethods.joined(separator: "\n  "))
    }
    """
    
    try code.write(to: outputFile, atomically: false, encoding: .utf8)
  }
  
  private func populateSegments() {
    // Recursively find all .swift files
    let swiftFiles = findSwiftFiles(in: inputFolder)
    
    for file in swiftFiles {
      let pageInfos = extractPageInfo(from: file)
      
      for pageInfo in pageInfos {
        let hasParameters = pageInfo.route.name.contains("{")
        let newRoute = RouteInfo(
          route: pageInfo.route,
          typeName: pageInfo.typeName,
          hasParameters: hasParameters
        )
        
        // Check for duplicate/conflicting routes
        if let conflictingRoute = findConflictingRoute(newRoute, in: routeInfos) {
          fatalError("""
            ❌ ROUTE CONFLICT DETECTED:
            
            Route pattern '\(newRoute.route)' in '\(newRoute.typeName)' conflicts with:
            Route pattern '\(conflictingRoute.route)' in '\(conflictingRoute.typeName)'
            
            These routes would match the same URLs at runtime.
            Parameter names don't matter - only the pattern structure matters.
            
            Examples that conflict:
            - "home/products/{pid}" and "home/products/{productId}" ❌ (same pattern)
            
            Examples that don't conflict:
            - "home/products" and "home/products/{id}" ✅ (different segment count)
            - "home/products/{id}" and "home/products/{id}/edit" ✅ (different segment count)
            - "home/products/{id}" and "home/settings/{id}" ✅ (different static parts)
            """)
        }
        
        routeInfos.append(newRoute)
      }
    }
  }
  
  /// Checks if a route conflicts with existing routes
  /// Routes conflict if they would match the same URLs at runtime
  private func findConflictingRoute(_ newRoute: RouteInfo, in existingRoutes: [RouteInfo]) -> RouteInfo? {
    for existingRoute in existingRoutes {
      if routesConflict(newRoute.route.name, existingRoute.route.name) {
        return existingRoute
      }
    }
    return nil
  }
  
  /// Determines if two route patterns would conflict
  /// Routes conflict if they have the same structure (same number of segments and same static parts)
  private func routesConflict(_ route1: String, _ route2: String) -> Bool {
    // Split routes into segments
    let segments1 = route1.split(separator: "/").map(String.init)
    let segments2 = route2.split(separator: "/").map(String.init)
    
    // Different number of segments = no conflict
    if segments1.count != segments2.count {
      return false
    }
    
    // Compare each segment
    for (seg1, seg2) in zip(segments1, segments2) {
      let isParam1 = seg1.hasPrefix("{") && seg1.hasSuffix("}")
      let isParam2 = seg2.hasPrefix("{") && seg2.hasSuffix("}")
      
      // If both are parameters, they match (param names don't matter)
      if isParam1 && isParam2 {
        continue
      }
      
      // If one is a parameter and one is static, no conflict
      if isParam1 != isParam2 {
        return false
      }
      
      // Both are static - must match exactly
      if seg1 != seg2 {
        return false
      }
    }
    
    // All segments match = conflict!
    return true
  }
  
  /// Converts a route pattern to a regex pattern
  /// Example: "home/product/{id}" -> "/home/product/[^/]+"
  private func convertRouteToRegex(_ route: String) -> String {
    var regex = route
    
    // FIRST: Replace {paramName} with a placeholder that won't be escaped
    let placeholder = "___PARAM___"
    regex = regex
      .replacingOccurrences(
        of: "\\{[^}]+\\}",
        with: placeholder,
        options: .regularExpression
      )
      .replacingOccurrences(of: ".", with: "\\\\.")
      .replacingOccurrences(of: "?", with: "\\\\?")
      .replacingOccurrences(of: "+", with: "\\\\+")
      .replacingOccurrences(of: "*", with: "\\\\*")
      .replacingOccurrences(of: "(", with: "\\\\(")
      .replacingOccurrences(of: ")", with: "\\\\)")
      .replacingOccurrences(of: "[", with: "\\\\[")
      .replacingOccurrences(of: "]", with: "\\\\]")
      // FINALLY: Replace placeholder with the regex pattern for parameters
      .replacingOccurrences(of: placeholder, with: "[^/]+")
    
    // Add leading slash if not present
    return regex.hasPrefix("/") ? regex : "/\(regex)"
  }
  
  /// Recursively finds all .swift files in the given directory
  private func findSwiftFiles(in directory: URL) -> [URL] {
    var swiftFiles: [URL] = []
    
    guard let enumerator = FileManager.default.enumerator(
      at: directory,
      includingPropertiesForKeys: [.isRegularFileKey],
      options: [.skipsHiddenFiles]
    ) else {
      return swiftFiles
    }
    
    for case let fileURL as URL in enumerator {
      guard fileURL.pathExtension == "swift" else { continue }
      swiftFiles.append(fileURL)
    }
    
    return swiftFiles
  }
  
  /// Extracts @Page macro information from a Swift file
  private func extractPageInfo(from file: URL) -> [(route: (name: String, params: [(name: String, type: String)]), typeName: String)] {
    guard let source = try? String(contentsOf: file, encoding: .utf8) else {
      return []
    }
    
    // Parse the Swift file
    let sourceFile = Parser.parse(source: source)
    
    // Visit the syntax tree to find @Page attributes
    let visitor = PageAttributeVisitor(viewMode: .sourceAccurate)
    visitor.walk(sourceFile)
    
    return visitor.pageInfos
  }
}

/// Visitor that walks through Swift syntax to find @Page attributes
class PageAttributeVisitor: SyntaxVisitor {
  var pageInfos: [(route: (name: String, params: [(name: String, type: String)]), typeName: String)] = []
  
  override func visit(_ node: StructDeclSyntax) -> SyntaxVisitorContinueKind {
    // Check if this struct has a @Page attribute
    for attribute in node.attributes {
      guard case let .attribute(attr) = attribute else { continue }
      
      // Check if this is a @Page attribute
      guard let identifierType = attr.attributeName.as(IdentifierTypeSyntax.self),
            identifierType.name.text == "Page" else {
        continue
      }
      
      // Extract the route argument
      if let arguments = attr.arguments?.as(LabeledExprListSyntax.self),
         let routeArg = arguments.first(where: { $0.label?.text == "route" }) {
        
        let route = extractRoute(from: routeArg.expression)
        let typeName = node.name.text
        
        pageInfos.append((route: route, typeName: typeName))
        break // Only one @Page per struct, but continue to next struct
      }
    }
    
    return .visitChildren
  }
  
  /// Extracts route string from expression, handling string interpolations
  private func extractRoute(from expression: ExprSyntax) -> (name: String, params: [(name: String, type: String)]) {
    if let stringLiteral = expression.as(StringLiteralExprSyntax.self) {
      var route = (name: "", params: [(name: String, type: String)]())
      
      for segment in stringLiteral.segments {
        switch segment {
        case .stringSegment(let stringSegment):
          route.name += stringSegment.content.text
          
        case .expressionSegment(let exprSegment):
          // This is an interpolation like \(param: "id", Int.self)
          // Extract the parameter name
          if let param = extractParamName(from: exprSegment) {
            route.name += "{\(param.name)}"
            route.params.append((param.name, param.type))
          }
        }
      }
      
      return route
    }
    
    return ("", [])
  }
  
  /// Extracts parameter name from interpolation expression
  private func extractParamName(from segment: ExpressionSegmentSyntax) -> (name: String, type: String)? {
    // The expression is something like: param: "id", Int.self
    // We need to extract the string literal value
    
    let expressions = segment.expressions
    var paramName: String?
    var paramType: String?
    
    for expr in expressions {
      // Look for labeled expression with label "param"
      if expr.label?.text == "param",
         let stringLiteral = expr.expression.as(StringLiteralExprSyntax.self),
         let firstSegment = stringLiteral.segments.first,
         case .stringSegment(let stringSegment) = firstSegment {
        paramName = stringSegment.content.text
      }
      
      if expr.label == nil,
         let memberAccess = expr.expression.as(MemberAccessExprSyntax.self),
         memberAccess.declName.baseName.text == "self",
         let base = memberAccess.base {
        // Extract type name from Type.self
        paramType = base.description.trimmingCharacters(in: .whitespaces)
      }
    }
    
    return paramName.map {
      ($0, paramType ?? "String")
    }
  }
}
